import { Observer } from "../core/observer";
import { CompiledTemplate, QWeb } from "../qweb/index";
import { VNode } from "../vdom/index";
import "./directive";
import { Fiber } from "./fiber";
import "./props_validation";
import { Scheduler } from "./scheduler";
import { Browser } from "../browser";
/**
 * Owl Component System
 *
 * This file introduces a declarative and composable component system. It
 * contains:
 *
 * - the Env interface (generic type for the environment)
 * - the Internal interface (the owl specific metadata attached to a component)
 * - the Component class
 */
/**
 * An Env (environment) is an object that will be (mostly) shared between all
 * components of an Owl application.  It is the location which should contain
 * the qweb instance necessary to render all components.
 *
 * Note that it is totally fine to extend the environment with application
 * specific keys/objects/whatever.  For example, a key `isMobile` (to declare
 * if we are in "mobile" mode), or a shared bus could be useful.
 */
export interface Env {
    qweb: QWeb;
    browser: Browser;
}
export declare type MountPosition = "first-child" | "last-child" | "self";
interface MountOptions {
    position?: MountPosition;
}
/**
 * This is mostly an internal detail of implementation. The Meta interface is
 * useful to typecheck and describe the internal keys used by Owl to manage the
 * component tree.
 */
interface Internal<T extends Env> {
    readonly id: number;
    depth: number;
    vnode: VNode | null;
    pvnode: VNode | null;
    isMounted: boolean;
    isDestroyed: boolean;
    parent: Component<any, T> | null;
    children: {
        [key: number]: Component<any, T>;
    };
    cmap: {
        [key: number]: number;
    };
    currentFiber: Fiber | null;
    parentLastFiberId: number;
    scope: any;
    boundHandlers: {
        [key: number]: any;
    };
    observer: Observer | null;
    renderFn: CompiledTemplate;
    mountedCB: Function | null;
    willUnmountCB: Function | null;
    willPatchCB: Function | null;
    patchedCB: Function | null;
    willStartCB: Function | null;
    willUpdatePropsCB: Function | null;
    classObj: {
        [key: string]: boolean;
    } | null;
    refs: {
        [key: string]: Component<any, T> | HTMLElement | undefined;
    } | null;
}
export declare const portalSymbol: unique symbol;
export declare class Component<Props extends {} = any, T extends Env = Env> {
    readonly __owl__: Internal<T>;
    static template?: string | null;
    static _template?: string | null;
    static current: Component | null;
    static components: {};
    static props?: any;
    static defaultProps?: any;
    static env: any;
    static scheduler: Scheduler;
    /**
     * The `el` is the root element of the component.  Note that it could be null:
     * this is the case if the component is not mounted yet, or is destroyed.
     */
    get el(): HTMLElement | null;
    env: T;
    props: Props;
    /**
     * Creates an instance of Component.
     *
     * Note that most of the time, only the root component needs to be created by
     * hand.  Other components should be created automatically by the framework (with
     * the t-component directive in a template)
     */
    constructor(parent?: Component<any, T> | null, props?: Props);
    /**
     * willStart is an asynchronous hook that can be implemented to perform some
     * action before the initial rendering of a component.
     *
     * It will be called exactly once before the initial rendering. It is useful
     * in some cases, for example, to load external assets (such as a JS library)
     * before the component is rendered.
     *
     * Note that a slow willStart method will slow down the rendering of the user
     * interface.  Therefore, some effort should be made to make this method as
     * fast as possible.
     *
     * Note: this method should not be called manually.
     */
    willStart(): Promise<void>;
    /**
     * mounted is a hook that is called each time a component is attached to the
     * DOM. This is a good place to add some listeners, or to interact with the
     * DOM, if the component needs to perform some measure for example.
     *
     * Note: this method should not be called manually.
     *
     * @see willUnmount
     */
    mounted(): void;
    /**
     * The willUpdateProps is an asynchronous hook, called just before new props
     * are set. This is useful if the component needs some asynchronous task
     * performed, depending on the props (for example, assuming that the props are
     * some record Id, fetching the record data).
     *
     * This hook is not called during the first render (but willStart is called
     * and performs a similar job).
     */
    willUpdateProps(nextProps: Props): Promise<void>;
    /**
     * The willPatch hook is called just before the DOM patching process starts.
     * It is not called on the initial render.  This is useful to get some
     * information which are in the DOM.  For example, the current position of the
     * scrollbar
     */
    willPatch(): any;
    /**
     * This hook is called whenever a component did actually update its props,
     * state or env.
     *
     * This method is not called on the initial render. It is useful to interact
     * with the DOM (for example, through an external library) whenever the
     * component was updated.
     *
     * Updating the component state in this hook is possible, but not encouraged.
     * One need to be careful, because updates here will cause rerender, which in
     * turn will cause other calls to updated. So, we need to be particularly
     * careful at avoiding endless cycles.
     */
    patched(): void;
    /**
     * willUnmount is a hook that is called each time just before a component is
     * unmounted from the DOM. This is a good place to remove some listeners, for
     * example.
     *
     * Note: this method should not be called manually.
     *
     * @see mounted
     */
    willUnmount(): void;
    /**
     * catchError is a method called whenever some error happens in the rendering or
     * lifecycle hooks of a child.
     *
     * It needs to be implemented by a component that is designed to handle the
     * error properly.
     */
    catchError?(error?: Error): void;
    /**
     * Mount the component to a target element.
     *
     * This should only be done if the component was created manually. Components
     * created declaratively in templates are managed by the Owl system.
     *
     * Note that a component can be mounted an unmounted several times
     */
    mount(target: HTMLElement | DocumentFragment, options?: MountOptions): Promise<void>;
    /**
     * The unmount method is the opposite of the mount method.  It is useful
     * to call willUnmount calls and remove the component from the DOM.
     */
    unmount(): void;
    /**
     * The render method is the main entry point to render a component (once it
     * is ready. This method is not initially called when the component is
     * rendered the first time).
     *
     * This method will cause all its sub components to potentially rerender
     * themselves.  Note that `render` is not called if a component is updated via
     * its props.
     */
    render(force?: boolean): Promise<void>;
    /**
     * Destroy the component.  This operation is quite complex:
     *  - it recursively destroy all children
     *  - call the willUnmount hooks if necessary
     *  - remove the dom node from the dom
     *
     * This should only be called manually if you created the component.  Most
     * components will be automatically destroyed.
     */
    destroy(): void;
    /**
     * This method is called by the component system whenever its props are
     * updated. If it returns true, then the component will be rendered.
     * Otherwise, it will skip the rendering (also, its props will not be updated)
     */
    shouldUpdate(nextProps: Props): boolean;
    /**
     * Emit a custom event of type 'eventType' with the given 'payload' on the
     * component's el, if it exists. However, note that the event will only bubble
     * up to the parent DOM nodes. Thus, it must be called between mounted() and
     * willUnmount().
     */
    trigger(eventType: string, payload?: any): void;
    /**
     * Private helper to perform a full destroy, from the point of view of an Owl
     * component. It does not remove the el (this is done only once on the top
     * level destroyed component, for performance reasons).
     *
     * The job of this method is mostly to call willUnmount hooks, and to perform
     * all necessary internal cleanup.
     *
     * Note that it does not call the __callWillUnmount method to avoid visiting
     * all children many times.
     */
    __destroy(parent: Component | null): void;
    __callMounted(): void;
    __callWillUnmount(): void;
    /**
     * Private trigger method, allows to choose the component which triggered
     * the event in the first place
     */
    __trigger(component: Component, eventType: string, payload?: any): void;
    /**
     * The __updateProps method is called by the t-component directive whenever
     * it updates a component (so, when the parent template is rerendered).
     */
    __updateProps(nextProps: Props, parentFiber: Fiber, scope: any): Promise<void>;
    /**
     * Main patching method. We call the virtual dom patch method here to convert
     * a virtual dom vnode into some actual dom.
     */
    __patch(target: HTMLElement | VNode | DocumentFragment, vnode: VNode): void;
    /**
     * The __prepare method is only called by the t-component directive, when a
     * subcomponent is created. It gets its scope, if any, from the
     * parent template.
     */
    __prepare(parentFiber: Fiber, scope: any, cb: CallableFunction): Fiber;
    /**
     * Apply the stylesheets defined by the component. Note that we need to make
     * sure all inherited stylesheets are applied as well.  We then delete the
     * `style` key from the constructor to make sure we do not apply it again.
     */
    private __applyStyles;
    __getTemplate(qweb: QWeb): string;
    __prepareAndRender(fiber: Fiber, cb: CallableFunction): Promise<void>;
    __render(fiber: Fiber): void;
    /**
     * Only called by qweb t-component directive (when t-keepalive is set)
     */
    __remount(): void;
    /**
     * Apply default props (only top level).
     *
     * Note that this method does modify in place the props
     */
    __applyDefaultProps(props: Object, defaultProps: Object): void;
}
export {};
