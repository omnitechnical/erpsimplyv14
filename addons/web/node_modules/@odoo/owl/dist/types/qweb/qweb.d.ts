import { EventBus } from "../core/event_bus";
import { h, VNode } from "../vdom/index";
import { CompilationContext } from "./compilation_context";
/**
 * Owl QWeb Engine
 *
 * In this file, you will find a QWeb engine/template compiler.  It is the core
 * of how Owl component works.
 *
 * Briefly, Owl QWeb compiles XML templates into functions that output a virtual
 * DOM representation.
 *
 * We have here:
 * - a CompilationContext class, which is an internal object that contains all
 *   compilation specific information, while a template is being compiled.
 * - a QWeb class: this is the code of the QWeb compiler.
 *
 * Note that this file does not contain the implementation of the QWeb
 * directives (see qweb_directives.ts and qweb_extensions.ts).
 */
export declare type EvalContext = {
    [key: string]: any;
};
export declare type CompiledTemplate = (context: EvalContext, extra: any) => VNode;
interface Template {
    elem: Element;
    fn: CompiledTemplate;
}
interface CompilationInfo {
    node: Element;
    qweb: QWeb;
    ctx: CompilationContext;
    fullName: string;
    value: string;
}
interface NodeCreationCompilationInfo extends CompilationInfo {
    nodeID: number;
    addNodeHook: Function;
}
export interface Directive {
    name: string;
    extraNames?: string[];
    priority: number;
    atNodeEncounter?(info: CompilationInfo): boolean | void;
    atNodeCreation?(info: NodeCreationCompilationInfo): void;
    finalize?(info: CompilationInfo): void;
}
interface QWebConfig {
    templates?: string;
    translateFn?(text: string): string;
}
interface Utils {
    toObj(expr: any): Object;
    shallowEqual(p1: Object, p2: Object): boolean;
    [key: string]: any;
}
export declare class QWeb extends EventBus {
    templates: {
        [name: string]: Template;
    };
    static utils: Utils;
    static components: any;
    static DIRECTIVE_NAMES: {
        [key: string]: 1;
    };
    static DIRECTIVES: Directive[];
    static TEMPLATES: {
        [name: string]: Template;
    };
    static nextId: number;
    h: typeof h;
    static dev: boolean;
    static slots: {};
    static nextSlotId: number;
    subTemplates: {
        [key: string]: number;
    };
    static subTemplates: {
        [id: number]: Function;
    };
    isUpdating: boolean;
    translateFn?: QWebConfig["translateFn"];
    constructor(config?: QWebConfig);
    static addDirective(directive: Directive): void;
    static registerComponent(name: string, Component: any): void;
    /**
     * Register globally a template.  All QWeb instances will obtain their
     * templates from their own template map, and then, from the global static
     * TEMPLATES property.
     */
    static registerTemplate(name: string, template: string): void;
    /**
     * Add a template to the internal template map.  Note that it is not
     * immediately compiled.
     */
    addTemplate(name: string, xmlString: string, allowDuplicate?: boolean): void;
    /**
     * Load templates from a xml (as a string or xml document).  This will look up
     * for the first <templates> tag, and will consider each child of this as a
     * template, with the name given by the t-name attribute.
     */
    addTemplates(xmlstr: string | Document): void;
    _addTemplate(name: string, elem: Element): void;
    _processTemplate(elem: Element): void;
    /**
     * Render a template
     *
     * @param {string} name the template should already have been added
     */
    render(name: string, context?: EvalContext, extra?: any): VNode;
    /**
     * Render a template to a html string.
     *
     * Note that this is more limited than the `render` method: it is not suitable
     * to render a full component tree, since this is an asynchronous operation.
     * This method can only render templates without components.
     */
    renderToString(name: string, context?: EvalContext, extra?: any): string;
    /**
     * Force all widgets connected to this QWeb instance to rerender themselves.
     *
     * This method is mostly useful for external code that want to modify the
     * application in some cases.  For example, a router plugin.
     */
    forceUpdate(): void;
    _compile(name: string, elem: Element, parentContext?: CompilationContext, defineKey?: boolean): CompiledTemplate;
    /**
     * Generate code from an xml node
     *
     */
    _compileNode(node: ChildNode, ctx: CompilationContext): void;
    _compileGenericNode(node: ChildNode, ctx: CompilationContext, withHandlers?: boolean): number;
    _compileChildren(node: ChildNode, ctx: CompilationContext): void;
}
export {};
