import { QWebVar } from "./expression_parser";
export declare const INTERP_REGEXP: RegExp;
export declare class CompilationContext {
    static nextID: number;
    code: string[];
    variables: {
        [key: string]: QWebVar;
    };
    escaping: boolean;
    parentNode: number | null | string;
    parentTextNode: number | null;
    rootNode: number | null;
    indentLevel: number;
    rootContext: CompilationContext;
    shouldDefineParent: boolean;
    shouldDefineScope: boolean;
    protectedScopeNumber: number;
    shouldDefineQWeb: boolean;
    shouldDefineUtils: boolean;
    shouldDefineRefs: boolean;
    shouldDefineResult: boolean;
    loopNumber: number;
    inPreTag: boolean;
    templateName: string;
    allowMultipleRoots: boolean;
    hasParentWidget: boolean;
    hasKey0: boolean;
    keyStack: boolean[];
    constructor(name?: string);
    generateID(): number;
    /**
     * This method generates a "template key", which is basically a unique key
     * which depends on the currently set keys, and on the iteration numbers (if
     * we are in a loop).
     *
     * Such a key is necessary when we need to associate an id to some element
     * generated by a template (for example, a component)
     */
    generateTemplateKey(prefix?: string): string;
    generateCode(): string[];
    withParent(node: number): CompilationContext;
    subContext(key: keyof CompilationContext, value: any): CompilationContext;
    indent(): void;
    dedent(): void;
    addLine(line: string): number;
    addIf(condition: string): void;
    addElse(): void;
    closeIf(): void;
    getValue(val: any): QWebVar | string;
    /**
     * Prepare an expression for being consumed at render time.  Its main job
     * is to
     * - replace unknown variables by a lookup in the context
     * - replace already defined variables by their internal name
     */
    formatExpression(expr: string): string;
    captureExpression(expr: string): string;
    /**
     * Perform string interpolation on the given string. Note that if the whole
     * string is an expression, it simply returns it (formatted and enclosed in
     * parentheses).
     * For instance:
     *   'Hello {{x}}!' -> `Hello ${x}`
     *   '{{x ? 'a': 'b'}}' -> (x ? 'a' : 'b')
     */
    interpolate(s: string): string;
    startProtectScope(codeBlock?: boolean): number;
    stopProtectScope(protectID: number): void;
}
