import { Env } from "./component/component";
import { Context } from "./context";
/**
 * Owl Store
 *
 * We have here:
 * - a Store class
 * - useStore hook
 * - useDispatch hook
 * - useGetters hook
 *
 * The Owl store is our answer to the problem of managing complex state across
 * components. The main idea is that the store owns some state, allow external
 * code to modify it through actions, and for each state changes,
 * connected component will be notified, and updated if necessary.
 *
 * Note that this code is partly inspired by VueX and React/Redux
 */
export interface EnvWithStore extends Env {
    store: Store;
}
export declare type Action = ({ state, dispatch, env, getters }: {
    state: any;
    dispatch: any;
    env: any;
    getters: any;
}, ...payload: any) => any;
export declare type Getter = ({ state: any, getters }: {
    state: any;
    getters: any;
}, payload?: any) => any;
interface StoreConfig {
    env?: Env;
    state?: any;
    actions?: {
        [name: string]: Action;
    };
    getters?: {
        [name: string]: Getter;
    };
}
export declare class Store extends Context {
    actions: any;
    env: any;
    getters: {
        [name: string]: (payload?: any) => any;
    };
    updateFunctions: {
        [key: number]: (() => boolean)[];
    };
    constructor(config: StoreConfig);
    dispatch(action: string, ...payload: any): Promise<void> | void;
}
interface SelectorOptions {
    store?: Store;
    isEqual?: (a: any, b: any) => boolean;
    onUpdate?: (result: any) => any;
}
export declare function useStore(selector: any, options?: SelectorOptions): any;
export declare function useDispatch(store?: Store): Store["dispatch"];
export declare function useGetters(store?: Store): Store["getters"];
export {};
