/**
 * Owl 2 VDOM
 */
export declare type Key = string | number;
export declare type VNodeEl = HTMLElement | Text | Comment | null;
declare type CreateHook = (el: VNodeEl) => void;
interface Hooks {
    create?: CreateHook;
}
export declare const enum NodeType {
    DOM = 0,
    Text = 1,
    Comment = 2,
    Data = 3,
    Multi = 4
}
export interface Handler {
    cb: (this: HTMLElement, ev: any) => any;
}
export interface VDOMNode<T> {
    type: NodeType.DOM;
    tag: string;
    el: HTMLElement | null;
    children: VNode<T>[];
    attrs: {
        [name: string]: string;
    };
    key: Key;
    on?: {
        [event: string]: Handler;
    };
}
export interface VTextNode {
    type: NodeType.Text;
    text: any;
    el: Text | null;
}
export interface VCommentNode {
    type: NodeType.Comment;
    text: string;
    el: Comment | null;
}
export interface VDataNode<T> {
    type: NodeType.Data;
    data: T;
    child: VNode<T> | null;
    key: Key;
    hooks: Hooks;
}
export interface VMultiNode<T> {
    type: NodeType.Multi;
    children: VNode<T>[];
}
export declare type VNode<T> = VDOMNode<T> | VTextNode | VDataNode<T> | VMultiNode<T> | VCommentNode;
export declare function patch<T>(el: HTMLElement | DocumentFragment, vnode: VNode<T>): VNodeEl;
/**
 * This function assumes that oldvnode has been patched first (and so, has valid
 * html or text elements)
 *
 * It mutates newVNode, to contains all actual
 * dom elements
 */
export declare function update<T>(vnode: VNode<T>, target: VNode<T>): void;
export declare function htmlToVDOM(html: string): VNode<any>[];
export {};
