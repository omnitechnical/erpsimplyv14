import { Fiber } from "./fiber";
import { CompiledTemplate, RenderContext } from "./qweb/compiler";
import { VDataNode } from "./vdom";
export interface FunctionComponent {
    template: string;
    name?: string;
    setup?: (props: any, env: any) => any | void | Promise<any | void>;
}
export interface ComponentData {
    fiber: Fiber;
    templateFn: CompiledTemplate;
    context: any;
}
export interface FnInstance {
    vtree: VTree;
    context: any;
}
export declare type VTree = VDataNode<ComponentData>;
interface SharedData {
    currentVTree: VTree | null;
}
export declare const shared: SharedData;
export declare class Component<Props = any, Env = any> {
    static template: string;
    props: Props;
    env: Env;
    el: HTMLElement | Text | Comment | null;
    __owl__: VTree | null;
    constructor(props: Props, env: Env);
}
declare type MountTarget = HTMLElement | DocumentFragment;
interface MountOptions {
    props?: Object;
    env?: Object;
}
export declare function mount(target: MountTarget, fn: FunctionComponent, options?: MountOptions): Promise<FnInstance>;
export declare function mount<C extends typeof Component>(target: MountTarget, Comp: C, options?: MountOptions): Promise<InstanceType<C>>;
export declare function mount(target: MountTarget, comp: Component, options?: MountOptions): Promise<Component>;
export declare function mount(target: MountTarget, fn: FnInstance, options?: MountOptions): Promise<FnInstance>;
export declare function render(tree: VTree): Promise<void>;
/**
 * Render a template to a html string.
 *
 * Note that this is more limited than the `render` method: it is not suitable
 * to render a full component tree, since this is an asynchronous operation.
 * This method can only render templates without components.
 */
export declare function renderToString(name: string, context?: RenderContext): string;
export {};
