import { Component } from "./component/component";
import { EventBus } from "./core/event_bus";
import { Observer } from "./core/observer";
export declare class Context extends EventBus {
    state: any;
    observer: Observer;
    rev: number;
    mapping: {
        [componentId: number]: number;
    };
    constructor(state?: Object);
    /**
     * Instead of using trigger to emit an update event, we actually implement
     * our own function to do that.  The reason is that we need to be smarter than
     * a simple trigger function: we need to wait for parent components to be
     * done before doing children components.  More precisely, if an update
     * as an effect of destroying a children, we do not want to call any code
     * from the child, and certainly not render it.
     *
     * This method implements a simple grouping algorithm by depth. If we have
     * connected components of depths [2, 4,4,4,4, 3,8,8], the Context will notify
     * them in the following groups: [2], [4,4,4,4], [3], [8,8]. Each group will
     * be updated sequentially, but each components in a given group will be done in
     * parallel.
     *
     * This is a very simple algorithm, but it avoids checking if a given
     * component is a child of another.
     */
    __notifyComponents(): Promise<void>;
}
/**
 * The`useContext` hook is the normal way for a component to register themselve
 * to context state changes. The `useContext` method returns the context state
 */
export declare function useContext(ctx: Context): any;
export declare function useContextWithCB(ctx: Context, component: Component, method: any): any;
